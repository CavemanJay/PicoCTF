# Buffer Overflow Writeups

This writeup covers the buffer overflow series of challenges (0-3)

## buffer overflow 0 

### Description

> Smash the stack
> Let's start off simple, can you overflow the correct buffer? The program is available [here](./buffer_overflow_0/vuln). You can view source [here](./buffer_overflow_0/vuln.c). And connect with it using: `nc saturn.picoctf.net 64712`

### Hints

> How can you trigger the flag to print?

> If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.

> Run `man gets` and read the BUGS section. How many characters can the program really read?

### Approach

Looking at the provided source code we can see that there is a function that will print the global `flag` variable called `sigsegv_handler`.
We also see that this function is registered as a signal handler for the [SIGSEGV](https://www.tutorialspoint.com/c_standard_library/c_function_signal.htm) signal which occurs when a segmentation fault (segfault) happens.

![](./images/bo0_signal_handler.png)

We can cause a segfault to happen by overflowing the input buffer until we overwrite the return address which will cause the program to attempt to read from invalid memory.
To this end, we know the buffer size is 100 so I inputted 110 characters and got the flag.

![](./images/bo0_flag.png)

